# 제 2장. 간단한 프로토콜

HTTP 프로토콜의 구조
<br>


# 2.1 HTTP는 클라이언트와 서버간의 통신을 한다

HTTP 프로토콜에서도 클라 ↔ 서버 간 통신을 한다. 클라이언트가 한 쪽은 텍스트 이미지 등과 같은 리소스가 필요하다고 요구, 제공하는 쪽이 서버.
</br></br>

# 2.2 리퀘스트와 리스폰스를 교환하여 성립

HTTP는 클라이언트로부터 요청, Request 송신, 그 결과 서버로부터 응답, Response로 되돌아온다. 서버는 Request를 수신하지 않으면 리스폰스도 발생 x

1) 클라이언트(Request) → 서버 
![1](https://user-images.githubusercontent.com/77109766/177003828-31d1835e-990e-490a-9c8c-050a765b562e.png)

2) 클라이언트 ← 서버(Response)
![2](https://user-images.githubusercontent.com/77109766/177003856-6675c988-3e55-4fe9-936d-7ffa80448e60.png)
</br></br>


# 2.3 HTTP는 상태를 유지하지 않는 프로토콜

HTTP는 상태를 계속 유지X, stateless 프로토콜이다. 이전에 보냈던 리퀘스트나 이미 돌려준 리스폰스에 대해 기억하지 않는다. 이는 많은 데이터를 빠르고 확실하게 처리하는 범위성을 확보하기 위해 간단히 설계되어 있는 것이다.

그러나 웹의 진화에 따라 stateless특성만으로 처리 힘든 일이 증가한다. 예를 들어, 로그인 상태 유지 기능. 

→ 이러한 기능을 위해 쿠키(Cookie) 기술이 도입된다. 이를 사용하여 HTTP를 이용한 통신에서도 상태를 계속 관리할 수 있게 된다.
</br></br>


# 2.4 리퀘스트 URL로 리소스를 식별

HTTP는 URI (Uniform Resource Identifiers)를 사용하여 인터넷 상의 리소스를 지정한다. 이 덕분에 인터넷 상의 어떤 장소에 있는 리소스도 호출 가능하다.

클라이언트는 리소스를 호출할 떄마다 리퀘스트를 송신할 때 리퀘스트 안에 URI를 포함해야 하며, 이를 지정하는 방법에는 여러 종류가 있다.

1) 모든 URI를 리퀘스트 URI에 포함한다.

```xml
GET [http://google.com/index.html](http://google.com/index.html) HTTP/1.1
```

2) Host 헤더 필드에 네트워크 로케이션을 포함한다.

```xml
GET /index.html HTTP/1.1
Host: google.com
```

3) 특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우, 리퀘스트 URI에 [*]을 지정할 수 있다. 

```xml
OPTIONS * HTTP/1.1
```
</br>

# 2.5 서버에 임무를 부여하는 HTTP 메소드

HTTP1.1에서 사용하는 메소드

### ✅ GET: 리소스 획득

리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다. 

리소스가 텍스트면 그대로 반환, GGI와 같은 프로그램이면 실행해서 출력된 내용을 돌려준다.

### ✅ POST: 엔티티 전송

GET으로도 엔티티 전송 가능하지만, 일반적으로 POST를 사용한다. 

### ✅ PUT: 파일 전송

FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다.

다만, HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일 업로드 가능하다는 보안 상의 문제도 있어 일반적인 웹 사이트에서는 사용되지 않는다. 

ex) 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루거나, REST와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있다.

### ✅ HEAD: 메시지 헤더 취득

GET과 같은 기능이지만, 메시지 바디는 돌려주지 않는다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.

### ✅ DELETE: 파일 삭제

PUT메소드와 반대로 동작, 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. HTTP/1.1 PUT와 마찬가지로 인증 기능이 없어 일반적인 웹에서 사용X

### ✅ OPTIONS: 제공하고 있는 메소드의 문의

리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용한다. 

### ✅ TRACE: 경로 조사

Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 

리퀘스트를 보낼 때 ‘Max-Forwards’라는 헤더 필드에 수치를 포함시켜 서버를 통과할 때마다 그 수치를 줄인다. 수치가 0이 된 곳을 끝으로, 리퀘스트를 마지막으로 수신한 곳에서 상태 코드 200 OK리스폰스를 되돌려준다.

클라이언트는 TRACE 메소드를 사용하여, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다. → ex) 프록시 등을 중계하여 오리진 서버에 접속할 때 그 동작을 확인하기 위해 사용된다. 

크로스 사이트 트레이싱XST 같은 보안 상의 문제 때문에 사용하지 않는다.

(이미지 51)

### ✅ CONNECT: 프록시에 터널링 요구

프록시에 터널 접속 확립을 요하여, TCP 통신을 터널링 시키기 위해 사용된다. 주로 SSL이랑 TLS등의 프로토콜로 암호화된 것을 터널링 시키기 위해 사용된다.

```xml
CONNECT 프록시 서버 : 포트 HTTP 버전
```
</br></br>

# 2.6 메소드를 사용해서 지시를 내리다

리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에 메소드라는 명령이 있다. 이는 리소스에 어떤 행동을 하라고 지시하는 것이다. ex) GET, POST, HEAD 등

HTTP/1.0과 HTTP/1.1에서 지원하고 있는 메소드

| 메소드 | 설명 |  있는 HTTP버전 |
| --- | --- | --- |
| GET | 리소스 받기 | 1.0 1.1 |
| POST | 엔티티 바디 전송 | 1.0 1.1 |
| PUT | 파일 전송 | 1.0 1.1 |
| HEAD | 메시지 헤더 받기 | 1.0 1.1 |
| DELETE | 파일 삭제 | 1.0 1.1 |
| OPTIONS | 서포트하고 있는 메소드 문의 | 1.1 |
| TRACE | 경로 조사 | 1.1 |
| CONNECT | 프록시에의 터널링 요구 | 1.1 |
| LINK | 리소스 간에 링크 관계를 확립 | 1.0 |
| UNLINK | 링크 관계 삭제 | 1.0 |

LINK, UNLINK는 1.1에서 폐기되어 사용X
</br></br>

# 2.7 지속 연결로 접속량을 절약

HTTP 초기 버전에서는 HTTP통신을 한 번 할 때마다 TCP에 의해 연결과 종료를 할 필요가 있었다.

초기 당시의 통신에서는 작은 사이즈의 텍스트를 보내는 정도였기 때문에 이렇게 기능 구현해도 문제가 없었다. 그러나 HTTP가 널리 보급되며, 다량의 이미지를 포함한 문서 등이 늘어나며 매번 리퀘스트 보내어 통신량이 늘어나는 문제가 발생한 것.
![3](https://user-images.githubusercontent.com/77109766/177003857-0e5ea1c1-402a-460d-89ce-60af9b375254.png)

### 1) 지속 연결

HTTP/1.1와 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해 지속연결 (Persistent Connectinos)이라는 방법을 고안했다. 어느 한 쪽이 명시적으로 연결 종류하지 않는 이상 TCP 연결을 계속 유지한다. 

### 지속 연결의 장점

- (TCP 커넥션의 연결과 종료를 반복되는 오버헤드를 줄여주어) 서버에 대한 부하가 경감된다.
- (오버헤드를 줄인 만큼 HTTP리퀘스트와 리스폰스가 빠르게 완료되어) 웹 페이지를 빨리 표시할 수 있다.
![4](https://user-images.githubusercontent.com/77109766/177003859-2be7b284-16a0-460b-9977-13c7873a82c3.png)


### 2) 파이프라인화

지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인(HTTP pipelining)화를 가능하게 한다. 

- 이전: 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행
- 파이프라인화: 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다. 여러 리퀘스트를 병행해서 보내, 일일이 리스폰스를 기다릴 필요x

ex) HTML 한 페이지에 10개의 이미지를 포함한 웹 페이지를 리퀘스트한 경우에는 개별 연결 < 지속 연결 < 파이프라인화 쪽이 리퀘스트 완료가 빠르다. 
</br></br>

# 2.8 쿠키를 사용한 상태 관리

HTTP는 stateless 프로토콜이기 때문에 과거의 리퀘스트와 리스폰스의 상태를 관리하지 않아, 과거 상태를 근거로 해 현재 리퀘스트를 처리할 수 없다.

ex) 웹 로그인 인증

이 같은 문제 보완위해 쿠기 시스템이 도입되었다. 리퀘스트와 리스폰스에 쿠키 정보를 추가해 클라이언트의 상태를 파악하기 위한 시스템이다.

- 쿠키는 서버 → 리스폰스로 보내진 Set-Cookie 라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 된다.
- 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자도응로 쿠키 값을 넣어서 송신한다.
- 서버는 이 쿠키를 확인하여 어느 클라가 접속했는지 체크하고, 서버 상의 기록을 확인하여 이전 상태를 알 수 있다.

1) 쿠키X 상태의 리퀘스트
- 클라이언트 -> 서버 : Request 송신
- 클라이언트 <- 서버 : Response + cookie 송신
  - 이 때, 서버는 쿠키를 발행, 누구에게 무엇을 전달했는지를 기억해둠

2) 2회째 이후 (쿠키O 상태)의 리퀘스트
- 클라이언트 -> 서버 : Request + cookie 송신
- 클라이언트 <- 서버 : Response 
  - 이 전의 기록을 
