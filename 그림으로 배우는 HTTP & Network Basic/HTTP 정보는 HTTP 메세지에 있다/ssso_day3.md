# 제3장. HTTP정보는 HTTP메시지에 있다

# 3.1 HTTP 메시지의 구조

HTTP메시지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열이다. 구성은 `메시지 헤더`와 `메시지 바디`로 구성되며, 첫 개행 문자로 이 둘을 구분한다. 다만 메시지 바디가 없을 때도 있다.

### HTTP 메시지 구조

✅ 메시지 헤더: 서버와 클라이언트가 꼭 처리해야 하는 Request, Response내용과 속성 등

✅ CR+LF: CR(Carriage Return: 16진수 0x0d)와 LF(Line Feed: 16진수 0x0a)

✅ 메시지 바디: 전송되는 데이터 그 자체

![검은색 및 보라색 미래지향적인 현대 무늬 5G 기술 프레젠테이션 (1)](https://user-images.githubusercontent.com/77109766/178095655-1b34a509-c344-444c-ae3e-494aa66d7329.png)
```xml
😁 16진수 

0xFF : 0x-진수표현, FF-실제 숫자

표기방법:
1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f 
0~9까지의 숫자와 A, B, C, D, E, F 영문 대문자 6개를 사용하여 16개의 숫자를 이용해 표현한다.
```

# 3.2 Request 메시지와 Response 메시지의 헤더 구조
Request 메시지와 Response 메시지의 메시지 헤더 내부는 다음과 같은 데이터로 구성된다. 

![3 2 Request, Response 메시지의 구조](https://user-images.githubusercontent.com/77109766/178095484-18bea71b-36dd-4a43-b2b9-3b75aa889751.png)


### Request 메시지의 헤더 구조

✅ Request line 

Request에 사용하는 메소드 + Request URI +  HTTP 버전이 포함된다.

✅ 헤더 필드 (Request, 일반, 엔티티 헤더 필드)

Request의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다. 

ex) 일반 헤더 필드, Request 헤더 필드, Response 헤더 필드, 엔티티 헤더 필드 등 4종류가 있다.

✅ 그 외

HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다.

### Response 메시지의 헤더 구조

✅ 상태 라인 

Response 결과를 나타내는 상태 코드와 설명 + HTTP 버전이 포함된다.

✅ 헤더 필드 (Response, 일반, 엔티티 헤더 필드)

Reponse의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다. 

✅ 그 외

HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다.

(64쪽 Request message, Response message의 예시)

# 3.3 인코딩으로 전송 효율을 높이다

HTTP로 데이터를 전송할 때, 인코딩(변환)을 통해 전송 효율을 높일 수 있다. 

인코딩의 장점: 다량의 액세스를 효율 좋게 처리할 수 있다.

단점: 인코딩 처리로 인해 CPU 등의 리소스는 보다 많이 소비하게 된다.

### Message 바디 vs. Entity 바디

```xml
- 메시지: HTTP 통신의 기본 단위로 옥텟 시퀀스로 구성되고 통신을 통해서 전송된다.
- 엔티티: Request, Response의 payload로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

* 엔티티란 HTTP메시지(request/response) 의 바디에 적재되는 실제 데이터
	헤더가 메타데이터라면, 바디는 실제 데이터이며, 이게 바로 엔티티다?? => payload라고도 함
* 메시지란 HTTP통신의 기본단위이며, http메시지 바디의 역할은 엔티티 바디를 운반하는 일
```

HTTP 메시지 바디의 역할은 **Request, Response에 관한 엔티티 바디를 운반하는 일**이다. 기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다. 

✨→ message vs. entity 알아두기 (찾아보기)

### 📌 콘텐츠 코딩 (압축해서 보내는 방식)

HTTP에서 엔티티 정보를 유지한 채로 압축하는 엔티티에 적용하는 인코딩 같은 기능을 `콘텐츠 코딩(Content Codings`)이라고 한다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다. 

ex) 메일에 파일 첨부 시 용량을 줄이기 위해 파일을 zip으로 압축한 뒤 첨부하는 것 같은 기능

![3 3 인코딩-콘텐츠 코딩](https://user-images.githubusercontent.com/77109766/178095486-a1119f07-e015-4fa4-be00-1a01d31dd061.png)

콘텐츠 압축의 예시

- gzip(GNU zip)
- compress(UNIX의 표준 압축)
- deflate(zlib)
- identity(인코딩 없음)

### 📌 청크 전송 코딩 (분해해서 보내는 방식)

`청크 전송 코딩(Chunked transfer Coding)` : 엔티티 바디를 청크(덩어리)로 분할하는 기능

HTTP 통신에서 REQUEST한 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터 전송 시 데이터를 분할해서 조금씩 표시할 수 있다.

![3 3 인코딩-청크 코딩](https://user-images.githubusercontent.com/77109766/178095485-41bf86bf-a5a9-4336-9435-b912ebf11ef2.png)

청크 전송 코딩 순서 ???

엔티티 바디를 청크(덩어리)로 분해

청크 사이즈를 16진수를 사용해 단락을 표시하고, 엔티티 바디 끝에는 ‘O(CR+LF)’를 기록한다. 

→ 청크 전송 코딩된 엔티티 바디는 클라이언트 측에서 원래의 엔티티 바디로 디코딩한다. → HTTP/1.1에는 전송 코딩(Transfer Codings)이라는 인코딩 방식에 따라 전송하는 구조가 마련돼있지만 전송 코딩에는 청크 전송 코딩만 정의되어 있다.

# 3.4 여러 데이터를 보내는 멀티 파트

### 📌 MIME(Multipurpose Internet Mail Extensios: 다목적 인터넷 메일 확장 사양)

이미지 등의 바이너리 데이터를 아스키 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정한다. 

→ ex) 이를 통하여 메일의 경우, 메일의 본문이나 복수의 첨부 파일을 붙여서 함께 보낼 수 있다. 

### 📌 멀티파트

HTTP도 멀티파트에 대응하고 있어, 하나의 메시지 바디 내부에 **엔티티를 여러 개 포함**시켜 보낼 수 있다. 

ex) 주로 이미지나 텍스트 파일 등을 업로드할 때 사용된다.

📌 멀티파트의 종류

✅ multipart/form-data

Web 폼으로부터 파일 업로드에 사용된다.

```xml
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="field1"

Joe Blow
--AaB03x
Content-Disposition: form-data; name="pics"; filename='file1.txt"
Content-Type: text/plain

... (file1.txt데이터) ...
--AaB03x--
```

✅ multipart/byteranges

상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다.

(설명추가하기)

# 3.5 레인지 Request

📌 레인지 리퀘스트 

요즘처럼 광대역의 네트워크 이용 전에는 대용량의 이미지와 데이터를 다운로드하기 어려웠다. 다운로드 중 커넥션이 끊어지면 다시 처음부터 다운해야 했기 때문. 

이러한 문제 해결 위해 이전에 다운로드 하던 곳에서부터 다운로드 재개할 수 있는 `리줌(resume)`이라는 기능이 필요하게 되었다. 

이 기능 실현 위한 기술이 `레인지 리퀘스트 (Range Request)` : 엔티티의 범위를 지정해서 다운로드를 하는 것이다.

```xml
* 리줌 : 이전에 다운로드 하던 곳에서부터 다운로드 재개할 수 있는 기능
```

레인지 Request시에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다. 

✅ 바이트 레인지의 형식 

5,001~10,000 바이트

5,001 바이트 이상

처음부터 3,000 바이트까지, 그리고 5,000~7,000 바이트까지의 복수 범위

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content라는 리스폰스 메시지가 되돌아온다. 또한, 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 돌아온다. 서버가 레인지 리퀘스트를 지원하지 않는 경우에는 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 돌아온다. 

# 3.6 콘텐츠 네고시에이션

📌 콘텐츠 네고시에이션이란?

클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다. 

제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단하고 있다. 판단 기준은 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤어 필드입니다. 

📌 콘텐츠 네고시에이션 종류

✅ 서버 구동형 네고시에이션

서버 측에서 콘텐츠 네고시에이션을 하는 방식이다. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해 자동적으로 처리를 한다.

✅ 에이전트 구동형 네고시에이션

클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식이다. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다.

JS등을 사용해서 웹 페이지에서 자동적으로 이것을 정하는 것도 있다. 

✅ 트랜스페어런트 네고시에이션

서버 구동형과 에이전트 구동형을 혼합한 것으로 서버와 클라이언트가 각각 콘텐츠 네고시에이션을 하는 방식이다.
