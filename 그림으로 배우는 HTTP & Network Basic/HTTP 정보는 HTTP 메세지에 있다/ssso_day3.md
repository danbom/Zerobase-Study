# 제3장. HTTP정보는 HTTP메시지에 있다

> 📑 HTTP정보는 HTTP메시지에 있다</br>
> 📂HTTP 메시지의 구조 </br>
> 📂인코딩 </br>
> 📌콘텐츠 코딩(압축)</br>
> 📌청크 코딩(분해) </br>
> 📂멀티파트</br>
> 📂레인지 리퀘스트</br>
> 📂콘텐츠 네고시에이션 </br></br>


# 3.1 HTTP 메시지의 구조

HTTP메시지는 복수 행(개행 문자는 CR+LF)의 데이터로 구성된 텍스트 문자열이다. 구성은 `메시지 헤더`와 `메시지 바디`로 구성되며, 첫 개행 문자로 이 둘을 구분한다. 다만 메시지 바디가 없을 때도 있다. </br>

### ✅ 메시지 헤더: 
서버와 클라이언트가 꼭 처리해야 하는 Request, Response내용과 속성 등

### ✅ CR+LF: 
CR(Carriage Return: 16진수 0x0d)와 LF(Line Feed: 16진수 0x0a)

```
CR, LF 모두 개행을 뜻한다.
CR(Carriage Return): 커서의 위치를 처음으로 옮기는 동작 (타자기 이용해 문서 작성하는 방법에서 유래)
LF(Line Feed): 하나의 줄 아래로 이동 
```

### ✅ 메시지 바디: 
전송되는 데이터 그 자체

![검은색 및 보라색 미래지향적인 현대 무늬 5G 기술 프레젠테이션 (1)](https://user-images.githubusercontent.com/77109766/178095655-1b34a509-c344-444c-ae3e-494aa66d7329.png)
```xml
😁 16진수 

0xFF : 0x-진수표현, FF-실제 숫자

표기방법:
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F 
0~9까지의 숫자와 A, B, C, D, E, F 영문 대문자 6개를 사용하여 16개의 숫자를 이용해 표현한다.
```

</br>

# 3.2 Request 메시지와 Response 메시지의 헤더 구조
Request 메시지와 Response 메시지의 메시지 헤더 내부는 다음과 같은 데이터로 구성된다. 

![3 2 Request, Response 메시지의 구조](https://user-images.githubusercontent.com/77109766/178095484-18bea71b-36dd-4a43-b2b9-3b75aa889751.png)

</br>

## 📌Request 메시지의 헤더 구조

### ✅ Request line 

Request에 사용하는 메소드 + Request URI +  HTTP 버전이 포함된다.

### ✅ 헤더 필드 (Request, 일반, 엔티티 헤더 필드)

Request의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다. 

ex) 일반 헤더 필드, Request 헤더 필드, Response 헤더 필드, 엔티티 헤더 필드 등 4종류가 있다.

### ✅ 그 외

HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다.

</br>

### 📌Response 메시지의 헤더 구조

### ✅ 상태 라인 

Response 결과를 나타내는 상태 코드와 설명 + HTTP 버전이 포함된다.

### ✅ 헤더 필드 (Response, 일반, 엔티티 헤더 필드)

Reponse의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함된다. 

### ✅ 그 외

HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우가 있다. </br>

</br>

# 3.3 인코딩

HTTP로 데이터를 전송할 때, 인코딩(변환)을 통해 전송 효율을 높일 수 있다. 

인코딩의 장점: 다량의 액세스를 효율 좋게 처리할 수 있다.

단점: 인코딩 처리로 인해 CPU 등의 리소스는 보다 많이 소비하게 된다.

```
* 인코딩: 바이너리 파일 -> 텍스트 파일
* 디코딩: 텍스트 파일 -> 바이너리 파일
```

</br>

## ✨Message 바디 vs. Entity 바디

```xml
- 메시지: HTTP 통신의 기본 단위로 옥텟 시퀀스(8비트)로 구성되고 통신을 통해서 전송된다.
- 엔티티: Request, Response의 payload로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다. 엔티티란 HTTP메시지(request/response) 의 바디에 적재되는 실제 데이터
```

HTTP 메시지 바디의 역할은 **Request, Response에 관한 엔티티 바디를 운반하는 일**이다. 기본적으로 메시지 바디와 엔티티 바디는 같지만 **전송 코딩이 적용된 경우**에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다. 

</br>

## 📌 콘텐츠 코딩 (압축해서 보내는 방식)

HTTP에서 엔티티 정보를 유지한 채로 압축하는 엔티티에 적용하는 인코딩 같은 기능을 `콘텐츠 코딩(Content Codings`)이라고 한다. 콘텐츠 코딩된 엔티티는 수신한 클라이언트 측에서 디코딩한다. 

ex) 메일에 파일 첨부 시 용량을 줄이기 위해 파일을 zip으로 압축한 뒤 첨부하는 것 같은 기능

![3 3 인코딩-콘텐츠 코딩](https://user-images.githubusercontent.com/77109766/178095486-a1119f07-e015-4fa4-be00-1a01d31dd061.png)

콘텐츠 압축의 예시

- gzip(GNU zip)
- compress(UNIX의 표준 압축)
- deflate(zlib)
- identity(인코딩 없음)

</br>

## 📌 청크 전송 코딩 (분해해서 보내는 방식)

`청크 전송 코딩(Chunked transfer Coding)` : 엔티티 바디를 청크(덩어리)로 분할하는 기능

HTTP 통신에서 REQUEST한 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터 전송 시 데이터를 분할해서 조금씩 표시할 수 있다.

![3 3 인코딩-청크 코딩](https://user-images.githubusercontent.com/77109766/178095485-41bf86bf-a5a9-4336-9435-b912ebf11ef2.png)

✅ 청크 전송 코딩 순서

엔티티 바디를 청크(덩어리)로 분해 → 청크 사이즈를 16진수를 사용해 단락을 표시하고, 엔티티 바디 끝에는 ‘O(CR+LF)’를 기록한다. → 청크 전송 코딩된 엔티티 바디는 클라이언트 측에서 원래의 엔티티 바디로 디코딩한다. 
</br>
→ HTTP/1.1에는 전송 코딩(Transfer Codings)이라는 인코딩 방식에 따라 전송하는 구조가 마련돼있지만 전송 코딩에는 청크 전송 코딩만 정의되어 있다.

</br>

# 3.4 멀티 파트

## 📌 MIME(Multipurpose Internet Mail Extensios: 다목적 인터넷 메일 확장 사양)

이미지 등의 바이너리 데이터를 아스키 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정한다. 

→ ex) 이를 통하여 메일의 경우, 메일의 본문이나 복수의 첨부 파일을 붙여서 함께 보낼 수 있다. 

이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되어서 이름에 Internet Mail이 들어가지만, 현재는 웹을 통해 여러 형태의 파일 전달하는데 쓰이고 있다.

</br>

## 📌 멀티파트

HTTP도 멀티파트에 대응하고 있어, 하나의 메시지 바디 내부에 **엔티티를 여러 개 포함**시켜 보낼 수 있다. 

ex) 주로 이미지나 텍스트 파일 등을 업로드할 때 사용된다.

### 📌 멀티파트의 종류

**✅ multipart/form-data**

Web 폼으로부터 파일 업로드에 사용된다.

```xml
Content-Type: multipart/form-data; boundary=AaB03x

--AaB03x
Content-Disposition: form-data; name="field1"

Joe Blow
--AaB03x
Content-Disposition: form-data; name="pics"; filename='file1.txt"
Content-Type: text/plain

... (file1.txt데이터) ...
--AaB03x--
```

**✅ multipart/byteranges**

상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용된다.
멀티파트는 파트마다 헤더 필드가 포함된다. 

```
HTTP/1.1 206 Partial Content
Date: Fri, 13 Jul 2012 ~
Last-Modified: Fri, 31 Aug~
Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

--THIS_STRING-_SEPARATES--
Content-Type: application/pdf
Content-Range: bytes 500-999/8000

...(지정한 범위의 데이터)...
--THIS_STRING-_SEPARATES--

Content-Type: application/pdf
Content-Range: bytes 7000-7999/8000

...(지정한 범위의 데이터)...
--THIS_STRING-_SEPARATES--
```
- HTTP 메시지로 멀티파트를 사용할 때는 Content-type 헤더 필드를 사용한다. 
- 멀티파트 각 엔티티를 구분하기 위해 'boundary'문자열을 사용한다. 
- 각 엔티티의 선두에는 'boundary' 문자열 앞에 '--'를 삽입한다. (ex. '--AaB03x', '--THIS_STRING-_SEPARATES')
- 멀티파트의 마지막에는 문자열의 마지막 부분에 '--'를 삽입한다. (ex. '--AaB03x--', '--THIS_STRING-_SEPARATES--')


</br>

# 3.5 레인지 Request

요즘처럼 광대역의 네트워크 이용 전에는 대용량의 이미지와 데이터를 다운로드하기 어려웠다. 다운로드 중 커넥션이 끊어지면 다시 처음부터 다운해야 했기 때문. 

이러한 문제 해결 위해 이전에 다운로드 하던 곳에서부터 다운로드 재개할 수 있는 `리줌(resume)`이라는 기능이 필요하게 되었다. 

이 기능 실현 위한 기술이 `레인지 리퀘스트 (Range Request)` : 엔티티의 범위를 지정해서 다운로드를 하는 것이다.

```xml
* 리줌 : 이전에 다운로드 하던 곳에서부터 다운로드 재개할 수 있는 기능
```

레인지 Request시에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다. 

✅ 바이트 레인지의 형식 

- 5,001~10,000 바이트

- 5,001 바이트 이상

- 처음부터 3,000 바이트까지, 그리고 5,000~7,000 바이트까지의 복수 범위

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content라는 리스폰스 메시지가 되돌아온다. 또한, 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 돌아온다. 서버가 레인지 리퀘스트를 지원하지 않는 경우에는 상태 코드 200 OK라는 리스폰스 메시지로 완전한 엔티티가 돌아온다. 

</br>

# 3.6 콘텐츠 네고시에이션

## 📌 콘텐츠 네고시에이션이란?

같은 콘텐츠(내용)이지만 여러 개의 페이지를 지닌 웹 페이지. 예를 들면, 내용은 같지만 영어판, 한국어판과 같이 표시되는 언어가 다른 웹 페이지. 

이러한 웹 페이지에서 서로 다른 언어를 주로 사용하는 브라우저가 같은 URI에 액세스할 때 각각 영어판과 한국어판 웹 페이지를 표시하며, 이러한 구조를 `콘텐츠 네고시에이션`이라고 한다.

</br>

클라이언트와 서버가 제공하는 리소스의 내용에 대해서 교섭하는 것이다. 

제공하는 리소스를 언어와 문자 세트, 인코딩 방식 등을 기준으로 판단하고 있다. 판단 기준은 리퀘스트 메시지에 포함된 다음과 같은 리퀘스트 헤더 필드이다.

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

> MDR  
HTTP에서, 컨텐츠 협상이란 동일한 URI에서 리소스의 서로 다른 버전을 서브하기 위해 사용되는 메커니즘으로, 사용자 에이전트가 사용자에게 제일 잘 맞는 것이 무엇인지(예를 들어, 문서의 언어, 이미지 포맷 혹은 컨텐츠 인코딩에 있어 어떤 것이 적절한지)를 명시할 수 있습니다.

</br>

## 📌 콘텐츠 네고시에이션 종류

### ✅ 서버 구동형 네고시에이션

**서버 측에서 콘텐츠 네고시에이션을 하는 방식**이다. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해 자동적으로 처리를 한다.

### ✅ 에이전트 구동형 네고시에이션

**클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식**이다. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다.

JS등을 사용해서 웹 페이지에서 자동적으로 이것을 정하는 것도 있다. 

### ✅ 트랜스페어런트 네고시에이션

서버 구동형과 에이전트 구동형을 혼합한 것으로 **서버와 클라이언트가 각각** 콘텐츠 네고시에이션을 하는 방식이다.
